""""""""""Learning Link:  https://seisman.github.io/how-to-write-makefile/overview.html
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
% 的意思是表示一个或多个任意字符
$@ : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， $@ 就是匹配于 目标中模式定义的集合。
$< : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 % ）定义的，那么 $< 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。
$% : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 foo.a(bar.o) ， 那么， $% 就是 bar.o ， $@ 就是 foo.a 。如果目标不是函数库文件 （Unix下是 .a ，Windows下是 .lib ），那么，其值为空。
$? : 所有比目标新的依赖目标的集合。以空格分隔。
$^ : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重 复的，那个这个变量会去除 重复的依赖目标，只保留一份。
$+ : 这个变量很像 $^ ，也是所有依赖目标的集合。只是它不去除重复的依赖目标
$* : 这个变量表示目标模式中 % 及其之前的部分。如果目标是 dir/a.foo.b ，并且 目标的模式是 a.%.b ，那么， $* 的值就是 dir/a.foo
wildcard ： %在变量定义和函数引用时无效，比如$SRC=$(wildcard *.c)不能写作$SRC=%.c 
notdir : 去除路径
patsubst :替换通配符

:-c 	只编译并生成目标文件。 
:-g 	生成调试信息。GNU 调试器可利用该信息。 
:-O0 不进行优化处理。
:-O 或 -O1 优化生成代码。
:-O2 进一步优化。
:-O3 比 -O2 更进一步优化，包括 inline 函数。 
::-M 自动寻找依赖关系,（GNU gcc/g++ 需要使用-MM, 否者会把标准库文件加进来）
:@ 字符在命令行前,这个命令不会被显示出来
:-n(--just-print) 只显示命令,不执行命令,可以用来查看命令执行的样子与顺序
:-s(--silent/--quiet) 全面禁止命令
:;字符,用来分割同一行多个命令,后面命令都是基于前面命令
:-在命令前面，不管命令出不出错，都认为成功
:-i(--ignore-errors),Makefile 中所有命令都忽略错误
:-k(--keep-going),某个规则出错，忽略该规则，继续执行其他规则
:CFLAGS 环境变量,定义以后就会使用该环境变量,
""""""""""传递变量到下层makefile
：执行subdir 文件夹中make
    subsystem:
        $(MAKE) -C subdir
:-e 总控Makefile 变量可以覆盖下层变量,默认不会覆盖
:export <variable ...>; 传递变量到下级Makefile,传递所有变量后面什么都不加
:unexport <variable ...>,不传递变量到下级Makefile
:MAKEFLAGS & SHELL 总是要传递到下层,这事系统级环境变量
:-C -f -h -o -W 这几个参数不往下传递
""""""""""ending
:-w(--pring-dirctory)  ex:make -w(会输出一些信息,除非-s(--slient,--no-print-dirctory))
:定义命令包（类似宏定义）
    define run-yacc
    yacc $(firstword $^)
    mv y.tab.c $@
    endef

    foo.c : foo.y
    $(run-yacc)
""""""""""特殊字符篇
: $$ 表示 $ 字符


""""""""""规则性变量篇
""""""""""模式变量
"我们可以给定一种“模式”，可以把变量定义在符 合这种模式的所有目标上。
%.o : CFLAGS = -O#给所有以 .o 结尾的目标定义目标变量


""""""""""局部变量篇
"为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，
"它可以 和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。
"而 不会影响规则链以外的全局变量的值。
<target ...> : <variable-assignment>;

    prog : CFLAGS = -g
    prog : prog.o foo.o bar.o
        $(CC) $(CFLAGS) prog.o foo.o bar.o
    
    prog.o : prog.c
        $(CC) $(CFLAGS) prog.c
    
    foo.o : foo.c
        $(CC) $(CFLAGS) foo.c
    
    bar.o : bar.c
        $(CC) $(CFLAGS) bar.c
    #不管全局的 $(CFLAGS) 的值是什么,这段依赖命令 $CFLAGS 都是 -g

""""""""""可定义变量篇
变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有 : 、 # 、 = 或是空字符（空格、回车等）。]
变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的 变量名。
传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如： MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。
:变量使用时候要加上 $ 符号，最好用() {} 把变量包括起来， 会在使用地方展开
:= 使用其他变量构造变量，可以使用后边变量，但可能引起无限递归(
            A = ${B}
            B = ${A}
::= 与= 效果类似，但是只能使用前面定义好的变量。
:?= 前面没定义过 ，则当前行定义成功，否者忽略当前行
:+= 给变量追加值

高级用法:
:替换字符
    foo := a.o b.o c.o  
    bar := $(foo:.o=.c)#替换foo 中所有.o 后缀为.c
    bar := $(foo:%.o=%.c)#替换foo 中所有.o 后缀为.c,静态模式？
:变量值在当成变量
    x = y
    y = z
    a := $($(x)#$(a)是z

    first_second = Hello
    a = first
    b = second
    all = $($a_$b)  

    a_objects := a.o b.o c.o
    1_objects := 1.o 2.o 3.o
    sources := $($(a1)_objects:.o=.c)#这样a1 = a(1),就可以分别表示不同结果
""""""""""end
""""""""""条件判断篇
""""""""""函数篇
:$(subst 要被替换的字符串,用来替换的字符串,被处理的字符串)：
$(wildcard 寻找的文件)
$(basename 文件名)



